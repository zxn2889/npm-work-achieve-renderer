import{shallowReactive as e,effect as n,reactive as t}from"@zxn2889/achieve-proxy";let o=null;function r(e){o=e}function l(){return o}function c(e){if(e.type===Fragment)return void e.children.forEach((e=>c(e)));if("object"==typeof e.type){const n=e._component.subTree;e.type._isKeepAlive?e._component.keptAlive.__deActivate(n):c(n)}const n=e._el.parentNode;n&&n.removeChild(e._el)}function s(e){const n=l();n&&n.mounted.push(e)}function i(e){return document.createElement(e)}function f(e,n){e.textContent=n}function u(e,n,t=null){n.insertBefore(e,t)}function a(e,n,t){if(/^on/.test(e)){let o=(n._evi||(n._evi={}))[e];if(t)if(o)o.value=t;else{o=n._evi[e]=e=>{if(e.timeStamp<o.attachTime)return!1;Array.isArray(o.value)?o.value.forEach((e=>e)):"[object Object]"===Object.prototype.toString.call(o.value)?console.warn("事件值要为函数"):o.value(e)},o.value=t,o.attachTime=performance.now();const r=e.slice(2).toLowerCase();n.addEventListener(r,o)}else o&&n.removeEventListener(type,o)}"class"===e?n.className=t:!function(e,n){return("INPUT"!==n.tagName||"form"!==e)&&e in n}(e,n)?n.setAttribute(e,t):"boolean"==typeof n[e]&&""===t?n[e]=!0:n[e]=t}const p=Symbol(),d=Symbol(),y=Symbol();function h(o){const{createElement:s,setTextContent:i,insert:f}=o;function u(o,_,b,v){o&&o.type!==_.type&&(c(o),o=null);const g=_.type;if("string"==typeof g)o?function(e,n){const t=n._el=e._el,o=e.props,r=n.props;for(const e in r)Object.hasOwnProperty.call(r,e)&&r[e]!==o[e]&&a(e,t,r[e]);m(e,n,t)}(o,_):function(e,n,t){const o=e._el=s(e.type),r=e.children;if(e.props)for(const n in e.props)a(n,o,e.props[n]);if("string"==typeof r)i(o,r);else if(Array.isArray(r))for(let e=0;e<r.length;e++)u(null,r[e],o);f(o,n,t)}(_,b,v);else if(g===d)if(o){const e=_._el=o._el;_.children!==o.children&&(e.nodeValue=_.children)}else{const e=_._el=document.createTextNode(_.children);f(e,b)}else if(g===y)o?m(o,_,b):_.children.forEach((e=>u(null,e,b)));else if(g===p);else if("object"==typeof g)if(o)!function(e,n,t,o){const r=n._component=e._component,{props:l}=r;if(function(e,n){const t=Object.keys(e),o=Object.keys(n);if(t!==o)return!0;for(let o=0;o<t;o++){if(e[o]!==n[o])return!0}return!1}(e.props,n.props)){const[e]=h(n.type.props,n.type);Object.keys(l).forEach((n=>{n in e?l[n]=e[n]:delete l[n]}))}}(o,_);else{const o=l();o._isCacheKeepAlive?o.keptAlive._activate(o.subTree,b,v):function(o,l,c){const s=o.type,{data:i,props:f,render:a,beforeCreate:p,created:d,beforeMounte:y,mounted:m,beforeUpdate:_,updated:b,setup:v}=s,[g,A]=h(f,o.props),E=o.children||{};p&&p.call();const T={state:t(i()),props:e(g),subTree:null,isMounted:!1,mounted:[]};o._component=T;let k,w=a;if(v){const e={attr:A,emit:(e,...n)=>function(e,n,t){const o=`on${e[0].toUpperCase()}${e.slice(1)}`;o in t?t[o](n):console.warn(`当前事件未定义，请查看事件名称 ${o} 是否正确`)}(e,n,T.props),slots:E};r(T);const n=v(shallowReadOnly(T.props),e);r(null),"function"==typeof n?w=n:k=n}const j=new Proxy(T,{get(e,n){const{state:t,props:o}=e;return t&&n in t?t[n]:o&&n in o?o[n]:k&&n in k?k[n]:"$slots"===n?E:(console.warn("当前组件不存在该属性"),null)},set(e,n,t){const{state:o,props:r}=e;if(o&&n in o)o[n]=t;else if(r&&n in r)r[n]=t;else{if(!k||!(n in k))return console.warn("当前组件不存在该属性"),!1;k[n]=t}}});d&&d.call(j),n((()=>{const e=w.call(j);T.isMounted?(_&&_.call(j),u(T.subTree,e,l,c),b&&b.call(j)):(y&&y.call(j),u(null,e,l,c),T.isMounted=!0,T.mounted&&T.mounted.forEach((e=>e(j)))),T.subTree=e}))}(_,b,v)}else"function"==typeof g&&(o||function(t,o,r){const l=t.type,c=t.type.options,s={props:e(c),subTree:null,isMounted:!1};t._component=s,n((()=>{const e=l(c);s.isMounted?u(s.subTree,e,o,r):(u(null,e,o,r),s.isMounted=!0),s.subTree=e}))}(_,b,v))}function h(e,n){const t={},o={};return Object.keys(n).forEach((r=>{r in e||"/^on/".text(r)?t[r]=n[r]:(console.warn("当前定义的属性在组件内没有定义，存放至 attr"),o[r]=n[r])})),[t,o]}function m(e,n,t){"string"==typeof n.children?(Array.isArray(e.children)&&e.children.forEach((e=>c(e))),i(t,n.children)):Array.isArray(n.children)?Array.isArray(e.children)?function(e,n,t){const o=e.children,r=n.children;let l=0,s=null,i=null;for(let e=0;e<r.length&&(s=o[e],i=r[e],i.key===s.key);e++)u(s,i,t),l++;const a=o.length,p=r.length,d=Math.max(a,p);let y=a-1,h=p-1;for(let e=d;e>=0&&(s=o[y],i=r[h],i.key===s.key);e--)u(s,i,t),y--,h--;if(y<l&&h>=l)for(let e=l;e<=h;e++)u(null,r[l],t,_(l,r));if(h<l&&y>=l)for(let e=l;e<=y;e++)c(o[e]);const m=new Array(h-l+1).fill(-1),b={};for(let e=l;e<=h;e++)b[r[e].key]=e;for(let e=l;e<=y;e++){s=o[e];const n=b[s.key];i=r[n],n>-1?(u(s,i,t),m[n-l]=e):c(s)}const v=function(e){const n=e.slice(),t=[0];let o,r,l,c,s;const i=e.length;for(o=0;o<i;o++){const i=e[o];if(0!==i){if(r=t[t.length-1],e[r]<i){n[o]=r,t.push(o);continue}for(l=0,c=t.length-1;l<c;)s=(l+c)/2|0,e[t[s]]<i?l=s+1:c=s;i<e[t[l]]&&(l>0&&(n[o]=t[l-1]),t[l]=o)}}l=t.length,c=t[l-1];for(;l-- >0;)t[l]=c,c=n[c];return t}(m),g=m.includes(-1);if(v.length<m.length||g){let e=v.length-1,n=m.length-1;for(;n>=0;n--)if(-1===m[n]){const e=n+l;u(null,r[e],t,_(e,r))}else if(n!==v[e]){let e=n+l;const o=r[e];f(o._el,t,_(e,r))}else e--}}(e,n,t):(i(el,""),n.children.forEach((e=>u(null,e,t)))):Array.isArray(e.children)?e.children.forEach((e=>c(e))):i(t,null)}function _(e,n){const t=n[e+1];return t?t._el:null}return{render:function(e,n){e?u(n._o_vnode,e,n):n._o_vnode&&c(n._o_vnode),n._o_vnode=e},patch:u}}export{i as createElement,h as createRenderer,l as getInstance,u as insert,s as onMounted,r as setInstance,f as setTextContent,c as unmount};
